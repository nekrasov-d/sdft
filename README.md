# Sliding Discrete Fourier Transform #

SystemVerilog RTL core prefroming SDFT (variable radix / precision)

Comes along with SSIDFT (Simplified Sliding Inverse Fourier Transform) module,
because this module is very simple and it was concidered as too small to make
an individual repo for it. They are supposed to work in pair anyway.

Terms:
  * N   : amount of points of the transform (aka frequency bins, also referred as F[:,k])
  * DW  : input data bit width
  * IDW : internal data bit width (IDW >= DW)
  * CW  : coefficient bit width (real or imaginary part of a twiddle)


Main spec:
  * Performs N-point simple frequency transform (precise in given bit width)
  * The amount of frequency bins N is statically configured and can be any
    integer (no difference in area consumption between N = 2**(int) and other N's)
  * Input data bit witdth and internal data bit width are parameters, IDW >= DW
  * Amount of multipliers needed: 4 IDW+CW bit multipliers <b>for any N</b>
  * Amount of adders needed: .... <b>for any N</b>
  * Estimated block RAM memory consumption: ... bit where CW,..
  * Twiddles could be stored in external (to sdft module) block RAM to be shared
    with some other logic (would require dual port RAM configuration), or
    generated by external cordic sine generator
  * Internal twiddles are static and written into ROM during frimware loading
  ( if EXTERNAL_TWIDDLE_ROM=="False" )
  * Special fix coefficient R see (Stability / noise accumulation section) is
    scaled to [0:2**DW-1) range and should be close to the maximum value.
    Static parameter.
  * Noise: TODO: calculate esimated noise


Spec for SSIDFT:
  * Performs roughly approximated inverse Fourier transform over as it was
  stated in te article (see Background).
  * Estimated noise level: TODO


### Background ###

This work is based on the article "Sliding Is Smoother Than Jumping" by Russell
Bradford, Richard Dobson and John Fitch

[PDF](https://quod.lib.umich.edu/cgi/p/pod/dod-idx/sliding-is-smoother-than-jumping.pdf?c=icmc;idno=bbp2372.2005.086;format=pdf)


The actual formula is taken from R.Lyons textbook [1] and is obtained with some
simple index manipulation:

F[t,k] = (F[t-1,k] + f[t] - f[t-N]) \* W[k]

where W[k] is k-th twiddle exp( 2jpk/N ) * c

This requires some samples "from the past", but we could assume that they were
zero before valid data.

### Bin overflows ###

We can't allow any saturation/overflow when computing F[t,k] and putting
these results into memory, because these results will be recursively used
for future samples, and once happened sat/overflow produces much more data
corruption then just by itself. This is why there were internal data width
and sat alarm designed. We need to increase IDW or attenuate input signal
untill it happens never or almost never.

I used to sat_alarm_o signal to blink led, and traded performance for bit width
until it stopped to happen. Fix coefficint (see the next section) also helps to
prevent overflows.

### Stability / noise accumulation ###

Look again at this formula: F[t,k] = (F[t-1,k] + f[t] - f[t-N]) \* W[k]
What if input signal f[t] suddenly became all zeros? There should nothing
left inside freuqncy bins soon, right? But because W[k] has the energy of
1, it doesn't attenuate frequency bin content, just turns the phase. Thus,
the only component that could zero the content of a frequency bin is the
delayed signal, f[t-N], and after N clocks it must fully compensate F[:,k].
But in practice I faced problems when it doesn't happen completely. Maybe
because of unprecise computations, floors, roundings, or some other unclear
reasons. But anyway, what is left in F[:,k] remains there forever,
accumulating and causing F[:,k] overflow. The solution could be found along with
consdering overall stabiliry. R.Lyons in his textbook [1]:

F[t,k] = (F[t-1,k] + f[t] - r \* f[t-N]) \* r \* W[k]

This fix coefficient r helps both preventing permanent noise accumulation and
making the design stable.

r \* W[k] could be pre-calculated if we use ROM to store twiddle values. If we
use some external cordic-based generator instead we might need this multiplier
anyway... well, actually, in desperate area-saving cases we could re-calculate
fixed cordic coefficint K.

### Windowing ###

Applying Hann windiw in frequency is not the same as aplying Hann window in
time and then do the transform. Yes, it gives some effect, but bin content
variating in time doesn't seem to be as smooth as if we perform hanning in
time domain. To obtain smooth frequency bin changes and mitigate some
transform artifacts one could do autoregression in frequency.

see python_mode/utility_functions.py: smoothing_fd()

This function applies forward rotation to each bin every sample, and could use
dual port twiddle ROM shared with SDFT, just start from the bottom and go up (if
initialized this ROM with counter clockwise ('inverse') twiddles for SDFT.

### Inverse transform ###

The idea behind SDFT is simple, it's easy to implement and effectively fits FPGA
resources. But what about inverse transform? The problem is that the information
about initial signal sample we want to reconstruct is scattered across N frequency
domain blocks. And to make precise sample reconstruction, we would need to store
N frequency domain blocks (N squared amount of complex data). It is absolutely
unefficent, especially for FPGA, were block RAM should be utilized wise. But the
autors of [1] states that we can use only one frequency domain block, except for the
0th one, and the results for one restored sample would be actually good enough
for many tasks, for example, for audio processing.

I tried to model it in Python and found out, that the distortion is actually not
so big (see more in Performance section), and it is relatively same for every
block we pick, except for 0th. But of course it's desireble to use N/2-th block,
because all the exponents are turned into just ones and minus ones. All we need
is just to switch sign. Doing this we discard imaginary part.

### Modeling results ###

### Hardware results ###

### Testbench ###

### References ###

### Autors ###

 -- Dmitry Nekrasov <bluebag@yandex.ru>  Sat, 13 Apr 2024 12:52:23 +0300

### License ###

MIT
